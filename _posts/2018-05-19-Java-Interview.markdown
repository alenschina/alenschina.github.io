---
layout:     post
title:      "Java面试题"
subtitle:   ""
date:       2018-05-19 13:00:00
author:     "Aaron"
header-img: "img/post-bg-2015.jpg"
catalog: false
tags:
    - Java
---



## 前言

公司最近正在努力招人，Aaron 也参与了一些面试，但是总觉得面试过程有点随意，不像一支正规码军，所以抽空整理一些 Java 面试的题目。目前的内容只是开始，会持续更新。
<br/>


---
## 正文

### 基础知识

>入门级

Q1: 解释Java的override和overload
```
override: 子类对父类方法的覆盖，只能比父类抛出更少的异常，访问权限不能小于父类方法。
```

>入门级

Q1.1: 仅函数的返回值不同可以构成overload吗？
```
不行，Java方法的调用不强制返回值赋值，所以仅返回值不同的方法在被调用的时候会被混淆
```

>入门级

Q2: 抽象类和接口的区别？
```
1. 抽象类中可以实现具体方法，接口只能定义抽象方法
2. 抽象类中可以由普通成员变量，接口中只能声明常量
3. 抽象类只能单继承，接口可以多实现
4. java 8之后，接口中可以实现default方法，即方法可以被实现
```

>入门级

Q2.1: 抽象类和接口如何选择？
```
一般而言，只有需要在父类中实现具体方法或者声明成员变量时，才选择使用抽象类而不是接口
```

>入门级

Q3: Java中的值传递和引用传递
```
值传递是传递对象的副本，所以对副本的改动不会影响到原对象。引用传递是传递的是对象的内存地址，操作的都是源对象
```

### 集合相关

>入门级

Q4: 列举Java中的常见集合
```
1. Map和Collection是所有集合类型的父接口
2. Collection的子接口有: Set接口和List接口
3. Set接口的主要实现类有: HashSet/TreeSet/LinkedHashSet等
4. List接口的主要实现类有: ArrayList/LinkedList/Stack/Vector等
5. Map接口的主要实现类有: HashMap/TreeMap/HashTable/ConcurrentHashMap/Properties等
```

>入门级

Q4.1: HashMap和HashTable的区别？
```
1. HashMap是线程不安全的，HashTable使用了synchronize关键字，是线程安全的
2. HashMap允许key值为null，HashTable不允许
```

>入门级

Q4.2: HashMap的底层实现？
```
1. HashMap底层就是一个数组结构，数组中的每一项是一个链表（如果存在指向下一项的引用）
2. Java8之后，HashMap由数组+链表+红黑树实现（如果数组大小扩展到64以上，就转换为树）
```

>入门级

Q4.3: ConcurrentHashMap和HashTable的区别？
```
HashMap没有考虑同步，是线程不安全的。HashTable在执行同步的时候会锁住整个结构。ConcurrentHashMap的同步更加细粒度，引入了“分断锁”的概念，会默认将Hash表分为16个segment，get/put/remove等操作只会对当前使用到的桶进行锁操作
```

>入门级

Q4.4: 解释集合对象的初始容量和加载因子？
```
集合对象在被申明的时候，会分配初始容量大小的内存空间，例如HashMap的初始容量为16。加载因子指的是当集合中entry的数量达到一定阈值后，集合会自动分配一段内存空间用于存放更多的entry，例如HashMap的threshold是0.75，则当一个HashMap的entry达到12的时候，它的size就会拓展到32
```

>入门级

Q4.5: CopyOnWriterArrayList和ArrayList的区别
```
CopyOnWriterArrayList是ArrayList的一个线程安全的变体。它的数据结构和方法和ArrayList一样，但是它的可变操作（如add，set）都是通过对底层数组进行一次新的复制来实现的。这种集合类型的开销比较大，一般使用的场景为：1. 无法进行同步遍历，但有需要解决并发冲突时；2. 当遍历操作远远大于可变操作时
```

>进阶级

Q4.6: CurrentHashMap的具体实现？
```
具体的不说了，可以写一篇文章来讲。简单一点讲，CurrentHashMap中主要的实体类是Segment和HashEntry，HashEntry就是用来封装映射表的键值对（和HashMap一样），Segment可以理解成CurrentHashMap中间分隔开的多个子Hash表，每个Segment守护一段Hash表中的HashEntry，对一段Hash表中的数据举行修改需要获得这个Segment的锁
```

>大咖级

Q4.7: HashMap的长度为什么是2的幂次方？（能答出这题的不是高手就是背过题库）
```
1. Key的定位是通过将Key的hash值与length-1进行&运算得出的，2的幂次方可以有效减少Hash冲突
2. length是2的幂次方，使得length-1的二进制必定是11111……的形式，在和key做&运算时效率会非常快
3. 如果length不是2的次幂，比如length=15，则length-1=14，二进制位1110，在和key做与操作时，最后一位都为0，这将导致0001，0011，0101，1001，1011，0111，1101这几个位置永远不能存放元素，是很大的空间浪费
```

### 多线程相关

我们反正也用不着


### JVM相关

>入门级

Q1: 解释-Xms、-Xmx这类参数
```
堆内存分配
1. -Xms：JVM初始分配内存，默认是物理内存的1/64
2. -XMx：JVM最大分配内存，默认是物理内存的1/4
3. 默认空余堆内存小于40%时，JVM就会增大堆内存直到-Xmx的最大限制；空余堆内存大于70%时，JVM就会减少堆内存直到-Xms的最小限制
4. 一般设置-Xms、-Xmx相等，以避免GC后JVM频繁调整堆内存大小

非堆内存分配
1. -XX:PermSize：非堆内存初始值，默认是物理内存的1/64
2. -XX:MaxPermSize：非堆内存最大值，默认是物理内存的1/4
```

>进阶级

Q2: 描述JVM内存划分
```
1. 方法区（method area）：常量、静态变量、JIT（即时编译器）编译后的代码都在方法区
2. 堆内存（heap）：垃圾回收的主要场所，全局共享
3. 程序计数器（program counter register）：当前线程执行的字节码的位置指示器（说白了就是指定执行哪条指令）
4. 虚拟机栈（VM stack）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量
5. 本地方法栈（native method stack）：为JVM提供使用native方法的服务
```

>进阶级

Q3: 垃圾回收的算法
```
1. 引用计数：原理是某对象有一个引用，即增加一个计数，删除一个引用，则减少一个计数，垃圾回收的时，只用收集计数为0的对象。此算法最致命的问题是无法处理循环引用的问题

2. 标记-清除：此算法分为两个阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法要暂停整个应用，且会产生大量内存碎片，因为回收后的空间是不连续的

3. 复制算法：此算法将现有的内存空间划分为两块相等的区域，每次只是用其中一块。在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除重在使用的内存块中的虽有对象。此算法复制成本较小，且复制过程中还能进行相应的内存整理。但是确定也很明显，需要两倍的内存空间。现在的商业虚拟机都采用这种算法回收新生代。因为新生代的对象绝大部分会被快速回收，所以不需要1:1的划分内存空间。例如HotSpot虚拟机默认Eden和Survivor的大小比例是8:1

4. 标记-整理：此算法优化了“标记-清除”算法，也分为两个阶段。第一阶段从根节点开始标记所有被引用的对象，第二阶段遍历整个堆，清除未标记的对象并且把存活的对象“压缩”的堆的其中一块（这一步可以理解成复制算法）。这种算法避免了内存碎片，也减少内存空间的需求。一般运用于老年代的对象回收
```

>进阶级

Q4: 描述GC发生的过程
```
首先要明白堆内存包含新生代和老年代，新生代还包含Eden和Survivor两块区域。当我们申明对象时，首先会向Eden区域申请内存空间，当Eden空间不足时，就会触发minor GC，这里就使用复制算法将存活对象复制到Survivor区域。当Survivor区域也没有足够空间容纳对象时，就会将对象放入老年代。当老年代的内存空间也不足时，就会触发full GC。full GC运用的就是标记-整理算法。
```